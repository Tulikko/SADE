---
title: "Final assignment"
author: "Uine Kailamäki"
date: "2021"
output: html_document
---


# Final assignment

## Task 1

Using Dataset 1, \
a) plot medieval settlements in the county of Kent, and \
b) run K, L and Pair Correlation Function analysis with 99 runs of Monte Carlo simulation on the data. 

```{r}

# Setting up WD and necessary libraries
setwd("~/R/SADE/week7")
library(rgdal)   
library(raster)   
library(spatstat) 
library(maptools)
library(GISTools)  

# Loading and plotting the polygon "kent"
polyg <- readOGR(dsn="kent")
plot(polyg)

# Adding Digital Elevation Model to the plot to visualize topography
dem <- raster("dem_england/dem_england_historic.tif")
plot(dem, add=T, col=terrain.colors(15))

# Adding the medieval settlements as points to the plot
sett <- readOGR(dsn="dataset1")
points(sett, pch=19, cex=0.2)

# Omitting points that might fall outside of the polygon 
sett <- sett[polyg, ]

# Inspecting how "dataset1" looks like
head(sett)
summary(sett)

# Converting the data into spastat object for analysis
sp_sett <- as.ppp(coordinates(sett),as.owin(polyg))

# K-Function analysis
# "Pois" is the expected Poisson line, the others are how the data compares to it with a few different edge corrections
k_fun <- Kest(sp_sett)
plot(k_fun, xlim=c(0,5000), main="K-Function analysis")

# L-Function analysis
# Same as K but "Pois" is straightened to a straight line
l_fun <- Lest(sp_sett)
plot(l_fun, xlim=c(0,5000), main="L-Function analysis")

# Pair Correlation Function analysis (PCF)
# Same principle as K, but different process ("donut rings")
# Expected Poisson is the green horizontal line
pc_fun <- pcf(sp_sett)
plot(pc_fun, xlim=c(0,5000), main="Pair Correlation Function analysis")

# Monte Carlo Simulation
pc_fun_100 <- envelope(sp_sett, pcf, nsim=99)
plot(pc_fun_100, xlim=c(0,20000), main="PCF with 99 MC Simulations")

```

## Task 2

Using Dataset 2, \
a) plot the distribution of medieval object findspots in the county of
Kent. \
b) Perform kernel density analysis on the findspots, using a few different search radii. \
c) Also perform a relative risk surface analysis, using the object type “seal matrix”.

```{r}

# Setting up WD and necessary libraries
setwd("~/R/SADE/week7")
library(rgdal)   
library(raster)   
library(spatstat) 
library(maptools)

# Loading and plotting the polygon "kent"
polyg2 <- readOGR(dsn="kent")
plot(polyg2)

# Adding Digital Elevation Model to the plot to visualize topography
dem <- raster("dem_england/dem_england_historic.tif")
plot(dem, add=T, col=terrain.colors(15))

# Adding the medieval object findspots as points to the plot
sett2 <- readOGR(dsn="dataset2")
points(sett2, pch=19, cex=0.2)

# Omitting points that might fall outside of the polygon 
sett2 <- sett2[polyg2, ]

# Inspecting how "dataset2" looks like
head(sett2)
summary(sett2)

# Converting the data into spastat object for analysis
sp_sett2 <- as.ppp(coordinates(sett2),as.owin(polyg2))

# Computation to determine an “optimal” bandwidth (sigma)
bw.diggle(sp_sett2)

# Kernel Density Estimate (KDE) 1
dens <- density(sp_sett2, sigma=14, edge=TRUE, eps=500)
plot(dens, col=heat.colors(10))
points(sett2, pch=19, cex=0.2)

# Kernel Density Estimate (KDE) 2
dens2 <- density(sp_sett2, sigma=1000, edge=TRUE, eps=500)
plot(dens2, col=heat.colors(10))
points(sett2, pch=19, cex=0.2)

# Kernel Density Estimate (KDE) 3
dens3 <- density(sp_sett2, sigma=5000, edge=TRUE, eps=500)
plot(dens3, col=heat.colors(10))
points(sett2, pch=19, cex=0.2)

# Kernel Density Estimate (KDE) 4
dens4 <- density(sp_sett2, sigma=10000, edge=TRUE, eps=500)
plot(dens4, col=heat.colors(10))
points(sett2, pch=19, cex=0.2)

# Kernel Density Estimate (KDE) 4
dens5 <- density(sp_sett2, sigma=100000, edge=TRUE, eps=500)
plot(dens5, col=heat.colors(10))
points(sett2, pch=19, cex=0.2)

# Seeing if one find type dominates the data
library(dplyr)
df <- data.frame(table(sett2$objecttype))
df %>%
  arrange(desc(Freq))

# Dividing data into "coin" and artifacts
coin <- sett2[sett2$objecttype == "COIN", ]
notcoin <- sett2[sett2$objecttype != "COIN", ]

# Converting the divided data into spastat objects for analysis
sp_coin <- as.ppp(coordinates(coin),as.owin(polyg2))
dens6 <- density(sp_coin, sigma=5000, edge=TRUE, eps=500)
plot(dens6, col=heat.colors(10))
points(coin, pch=19, cex=0.2)

sp_notcoin <- as.ppp(coordinates(notcoin),as.owin(polyg2))
dens7 <- density(sp_notcoin, sigma=5000, edge=TRUE, eps=500)
plot(dens7, col=heat.colors(10))
points(notcoin, pch=19, cex=0.2)


# Step 1: Creating and plotting multitype object "sp_seals" 
sp_seals <- as.ppp(coordinates(sett2),as.owin(polyg2))

yes <- as.ppp(coordinates(sett2[sett2$objecttype == "SEAL MATRIX",]),as.owin(polyg))
no <- as.ppp(coordinates(sett2[sett2$objecttype != "SEAL MATRIX",]),as.owin(polyg))
marks(sp_seals) <- as.factor(sett2$seals)

plot(polyg2, add=F)
plot(sp_seals, add=T)

# Step 2: Density estimate of all object finds
densobj <- density(sp_seals, sigma=5000, edge=TRUE, eps=500)
plot(densobj, col=topo.colors(50))
points(sp_seals, pch=19, cex=0.2)

# Step 3: Relative risk surface contrasting "SEAL MATRIX" with all object finds
rrs <- relrisk(sp_seals, sigma=5000, edge=TRUE, eps=500)
rrs[as.matrix(densobj)<(0.000000001)] <- NA

plot(rrs, col=rev(topo.colors(50)), add=F)
plot(yes, cex=0.5, add=T)

```

## Task 3

a) Perform aoristic analysis on Dataset 3, both on the whole dataset and on just the seal matrices. \
b) Include the graphs for aoristic weighing (bar charts) and \
c) for aoristic analysis with MC simulation (your choice of line, polygon “blocks colour” or boxplot charts), both for the overall and the seal matrices analyses.

```{r}


```

## Task 4

Perform PCA on dataset 4.

```{r}


```

## Task 5

Perform cluster analysis on dataset 4.

```{r}


```